# 日々の競プロで得た知見

## 分かってないこと

- DP
- 参照渡し

## 教訓

- 基本 long long 型を使う
  - 大きい値（$10^9$等）が条件にあった場合は特に気を付ける
  - INF でなく LINF

- 「l」（Lの小文字）は変数等に使用しない
  - 「l」「1」がフォントによっては見分けがつかず，デバッグの邪魔

- 問題の意味が分からなかったら，とりあえずノートやホワイトボードに色々書いてみる

- **まず全探索より始めよ**
  - 「なんか工夫したら奇麗に書けるのでは？」という心境にしてくる「全探索を使わないで解ける俺かっこいいトラップ問題」がある（ABC333Cなど）
  - 可能なループ回数は大体$10^9$程度まで
    - 基本$10^8$程度までと考えておく，$10^10$は完全に無理
  - 二，三重ループが間に合わないなら工夫して一，二重ループにできないか工夫する
  - 範囲を絞った全探索も考えてみよ

- **負の数のmodは負の数**
  - `-5 % 2` は `-1`

## 教訓から導いた問題を解くフロー

0. 問題・制約を見て，全く分からないなら別の問題へ
1. まず，制約から**全探索**が可能か考察
    - 具体的には多重ループ等で解集合を全列挙できるか（ABC333Cなど）
2. 全列挙無理ならアルゴリズムを考える

## プログラムのテクニック

### ◆  ソート

#### 昇順（小さい順）にソート  

- `sort(all(v));`

#### 降順（大きい順）にソート  

- `sort(rall(v));`  
`rall(v) = v.rbegin(),v.rend()`  
ソート前にマイナスをかけて昇順にソートした後マイナスをかけて戻す

#### vector<pair<ll, ll>> を first を基準にソート  

- `sort(all(vp));`  
ソートしたい値は first に入れておこう！

### ◆ vector ・ string

#### vector / string の特定の要素をカウントする  

- `count(all(s), 'o')`

#### string のスライス（string 文字列中の特定の範囲の文字列を抜き出す）  

- `S.substr(first, end)`  
`end` は `S.end()` がデフォルト

#### vector の最大値・最小値  

`*max_element(all(vec))`  
`*min_element(all(vec))`  
`max({2, 5, 1}) //5`  
`min({2, 5. 1}) //5`

#### vector を使った map(辞書型)の作り方

pair に (key, value) を入れる  
`vector<pair<ll, ll>>`

### ◆ 浮動小数点の丸め込み

浮動小数点型（double, float）を整数型（int, ll）に丸める

#### 正の無限大への丸め込み

- `std::ceil(-2.5) //-2`

#### 負の無限大への丸め込み

- `std::floor(-2.5) //-3`

#### 0 方向への丸め込み（小数点以下の情報を隠滅する）

- `(ll)-5.0 / (ll)2.0 //-2`  
（ただ割るだけ）

#### .4は絶対値が小さくなる方向へ，.5は絶対値が大きくなる方向への丸め込み

- `std::round(-2.5) //-3`

#### 最近接偶数への丸め込み（.5は一番近い偶数にする）

- `std::nearbyint(-2.5) //-2`

### ◆ おしゃれな書き方

- `if(ans < x) ans = x;` ではなく  
`ans = max(ans, x);` の方がかっこいい

## データ構造

- Union Find
- 優先度付きキュー
- セグラメント木

## アルゴリズム

- 尺取り法
- DP
- 二分探索 ←忘れがち
- 全探索 ←忘れがち
